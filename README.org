* Procedural Generation Experiments
** Main steps
   Simple L-systems plant generation

   1. Create a simple L-system
   2. Create a (turtle) interpretation 

** Framework steps
   - Clean the Makefiles

** Philosophy
  - Highly interactive
  - Climbing the ladder of abstraction

** Dependencies
  - SFML 2.4.1 [[https://www.sfml-dev.org/][Website]]
  - googletest 1.8.0 [[https://github.com/google/googletest][Github Repository]]
  - GSL (Guidelines Support Library) 2017-06-27 [[https://github.com/Microsoft/GSL][Github Repository]]

** Development Guidelines
*** In use
   - *Environment:* debian stretch chroot with these development packages: =g++ make git libsfml-dev googletest=
   - *Coding rule:* [[https://github.com/isocpp/CppCoreGuidelines][ISO C++ Core Guidelines]]
   - *Compilation:* =make=
   - *Testing suite:* [[https://github.com/google/googletest/][googletest]]


*** To consider
   - Static analysis (Coverity?)
   - Formal documentation (Doxygen?)

** Technologies employed
*** Easy way
    I use C++ 14 and SFML 2.x, as this is the framework I know best.

*** Other possibilities
   - *Hard(er) way:* Try to learn a more appropriate tool like a scripting language (Lua). Interacting with C++/SFML or with a completely new framework like LÃ–VE.
   - *Hard way:* The hard way is to pick a specific and precise, but unfamiliar, framework, like the Processing language.
   - *Strange way:* More an excuse than a real need, using this project to learn a language like a Lisp
     
** Thoughts dump
  - Huge literature on the subject and extremely developed existing software. Where is my place?

** (Re)sources
[[http://blog.rabidgremlin.com/2014/12/09/procedural-content-generation-l-systems/][Procedural content generation: L-Systems (by Rabidgremlin)]]
